# AI Builder Prompt Package: Epic 1 - Story E1.F2.S3: Mahamaya Matrix & Bimba Map Interaction Layer

**Context:** 4_Nara / Nara_Mode_Full_Dev_v1
**Epic:** Epic 1: Mahamaya Ground Implementation: The 64-Fold Archetypal Foundation
**Feature:** Backend System Development & Bimba Map Foundation
**Sub-Feature:** Interaction Logic between User's Mahamaya Matrix and Universal Bimba Map
**AI Builder Target:** Augment Code (Claude 4)

## 1. Story Definition

This story focuses on developing the backend logic and service layer that enables the user's specific Mahamaya Matrix (stored in MongoDB) to interact with the universal symbolic knowledge stored in the `bimba_map` (Neo4j graph database). The goal is to create a system where interpretations, suggestions, or practices generated by Nara's agent subsystems are deeply personalized by filtering or contextualizing `bimba_map` data through the lens of the user's unique archetypal identity (Mahamaya Matrix).

This involves creating services that can take elements from a user's Mahamaya Matrix (e.g., their primary Gene Key, astrological Sun sign, dominant Jungian element), query the `bimba_map` for related universal symbols and interpretations, and then synthesize personalized insights.

**Acceptance Criteria:**

*   **AC1 (Backend - Service Layer Design):** A well-defined service layer (or set of services) is designed within the backend to mediate interactions between the Mahamaya Matrix data (MongoDB) and the `bimba_map` (Neo4j).
*   **AC2 (Backend - Query Orchestration):** The service layer can receive user-specific archetypal data (e.g., a specific Gene Key ID, a planet in a sign) from the Mahamaya Matrix.
*   **AC3 (Backend - Contextualized Bimba Map Queries):** The service layer can dynamically construct and execute Cypher queries against the `bimba_map` based on the input user data to retrieve relevant universal symbolic information, correspondences, and interpretations.
*   **AC4 (Backend - Synthesis Logic - Basic):** Initial logic is implemented to synthesize or filter the results from the `bimba_map` based on the user's context. For example, if querying for tarot card meanings, the interpretation might be nuanced by the user's dominant element from their Jungian type.
*   **AC5 (Backend - API for Agent Subsystems):** An internal API or interface is exposed by this service layer that other agent subsystems (e.g., Oracle, Journal) can call to get personalized symbolic insights for a given user.
*   **AC6 (Performance):** The interaction layer is performant, ensuring that personalized insights can be generated without undue delay.
*   **AC7 (Documentation):** The design of the service layer, its interaction patterns, and the API it exposes are documented.

## 2. Technical Context

**From Epic 1: Mahamaya Ground Implementation:**

*   The `bimba_map` (Neo4j) holds universal symbolic knowledge, while the Mahamaya Matrix (MongoDB) holds user-specific instantiations.
*   The User Identity object (Mahamaya Matrix) conditions Nara's knowledge from the `bimba_map` to form contextualized insights.
*   This interaction is crucial for personalizing all Nara outputs.

**From Architecture Documents (feature-context-bimba-alignment-package_Part1.md & Part2.md):**

*   **System Architecture:** Three-layer distributed architecture: Frontend (Vue.js, Quasar), Back-to-Front (Node.js, Express), Backend (Python, Flask/FastAPI).
*   **BPMCP (Bimba-Pratibimba-Memory-MCP):** This interaction layer is a key part of the BPMCP's function.
    *   **Bimba (Neo4j):** Read-only access for universal symbolic data (`bimba_map`).
    *   **Pratibimba (MongoDB):** Read/write access for user-specific data (Mahamaya Matrix).
*   **Target Directory (Backend):** `/epii_app/friendly-file-backend/`
*   **Key Backend Components for this story:** Likely within `/epii_app/friendly-file-backend/services/` for the interaction service layer, potentially in a new module like `personalization_service.py` or `matrix_bimba_bridge.py`. It will need to interact with MongoDB access services and `bimba_map` query services (developed in E1.F2.S2).
*   **Communication:** This service will expose an internal API for other backend agent subsystems (A2A communication).

## 3. Constraints & Considerations

*   **Service-Oriented Approach:** Design with clean interfaces.
*   **Complexity of Synthesis:** Start with simple rules, plan for iteration.
*   **Caching:** Consider for performance.
*   **Error Handling:** Essential for interactions with two databases.
*   **Asynchronous Operations:** Likely needed for database calls.
*   **Modularity:** Design synthesis rules for easy extension.
*   **Dependencies:** Relies on completed Mahamaya Matrix storage (E1.F2.S1) and `bimba_map` foundation (E1.F2.S2).
*   **EFDD Not Found:** The Feature Definition Document (E1_F2_EFDD.md) was not available.

## 4. Inputs to AI Builder (Claude 4 - Augment Code)

*   Story description, acceptance criteria, and tasks for E1.F2.S3.
*   Conceptual design of the interaction service layer, including input (user context from Mahamaya Matrix) and output (personalized insights).
*   Example scenarios of personalization (e.g., how a Gene Key from user's matrix influences interpretation of a Tarot card from `bimba_map`).
*   Assumed data structures for Mahamaya Matrix (MongoDB documents) and `bimba_map` (Neo4j graph, as per E1.F2.S2).
*   Target directory structure within `/epii_app/friendly-file-backend/`.

## 5. Expected Outputs from AI Builder

1.  **Interaction Service Layer Design (Python - Flask/FastAPI context):
    *   Python module(s) for the service layer (e.g., `personalization_service.py`).
    *   Functions to retrieve specific data points from a user's Mahamaya Matrix (MongoDB - assume a MongoDB access utility/service exists or provide a mock).
    *   Functions to construct dynamic Cypher queries for the `bimba_map` based on user data.
    *   Functions to execute these queries against Neo4j (using the service developed in E1.F2.S2 or direct `neo4j` driver usage) and process results.
2.  **Synthesis Logic Implementation (Python):
    *   Initial algorithms/rules for combining user-specific data with `bimba_map` data to produce personalized insights. Provide examples for 1-2 scenarios.
    *   Example: If user's Jungian type is 'Fire', and a `bimba_map` query returns a symbol associated with 'Water', the synthesis logic might highlight the dynamic tension or complementary nature.
3.  **Internal API Definition (Python - Flask/FastAPI style):
    *   Example API endpoints or service methods that other agent subsystems can call.
    *   Input: User ID (to fetch Mahamaya Matrix), query parameters (e.g., type of insight needed).
    *   Output: Personalized symbolic data/interpretation.
4.  **Testing Guidance/Snippets:
    *   Suggestions for unit/integration tests for the service layer, covering data retrieval, query construction, synthesis, and API calls.
5.  **Documentation Snippets:
    *   Markdown snippets describing the service layer's architecture, data flow, and API usage.

## 6. Detailed Prompt for AI Builder (Claude 4 - Augment Code)

```
As an AI Code Augmentation assistant (Claude 4), your task is to help implement the backend components for Story E1.F2.S3: Mahamaya Matrix & Bimba Map Interaction Layer within the Nara project.

**Project Context:**
Nara has a Python backend (Flask/FastAPI) located in `/epii_app/friendly-file-backend/`. This story builds upon previous work establishing the Mahamaya Matrix (user-specific data in MongoDB, Story E1.F2.S1) and the Bimba Map (universal symbolic knowledge in Neo4j, Story E1.F2.S2).

**Story Goal:** Develop a backend service layer that personalizes universal symbolic knowledge from the `bimba_map` using a user's specific Mahamaya Matrix. This layer will serve personalized insights to other Nara agent subsystems.

**Key Requirements from Story & Technical Context:**

1.  **Service Layer Design (Python):
    *   Create a service (e.g., `personalization_service.py` or `matrix_bimba_bridge.py`) in the backend.
    *   This service needs to:
        *   Accept user identification (e.g., `user_id`) and context for the desired insight.
        *   Retrieve relevant data from the user's Mahamaya Matrix (MongoDB). Assume helper functions or another service exists for basic MongoDB document retrieval by `user_id`.
        *   Construct dynamic Cypher queries for the `bimba_map` (Neo4j) based on the user's matrix data and the insight context.
        *   Execute these queries (using services from E1.F2.S2 or direct `neo4j` driver) and retrieve universal symbolic data.

2.  **Synthesis Logic (Python):
    *   Implement initial logic to combine/filter/nuance the `bimba_map` results based on the user's Mahamaya Matrix data.
    *   **Example Scenario 1:** A user has 'Gene Key 25' as their primary Gene Key. The Oracle subsystem requests insights related to a 'Temperance' Tarot card drawn from the `bimba_map`. The synthesis logic should find connections between 'Gene Key 25' and 'Temperance' in the `bimba_map` (if they exist) or provide interpretations of 'Temperance' that are thematically aligned with 'Gene Key 25's core themes (e.g., acceptance, universal love).
    *   **Example Scenario 2:** A user's Jungian type indicates a 'Dominant Fire Element'. When querying for general interpretations of the 'Moon' (astrological planet) from the `bimba_map`, the synthesis logic might add a note about how the intuitive, watery nature of the Moon interacts with a fiery temperament.
    *   Focus on 1-2 clear, implementable synthesis examples.

3.  **Internal API for Agent Subsystems (Python - Flask/FastAPI style):
    *   Define how other backend services (agents) will call this personalization service.
    *   Example service method: `get_personalized_symbolic_insight(user_id: str, insight_request: dict) -> dict`
        *   `insight_request` could specify: `{'type': 'tarot_interpretation', 'card_name': 'Temperance', 'context_keys': ['primary_gene_key']}`
        *   The return would be a dictionary with the personalized insight.

4.  **Error Handling & Performance:
    *   Include basic error handling (e.g., user not found, symbol not found in `bimba_map`).
    *   Briefly mention considerations for performance (e.g., potential for caching, query optimization) though full implementation is not required in this step.

**Expected Output Structure:**

Organize your response into the following sections. Provide runnable Python code where applicable, assuming a standard Python project structure within `/epii_app/friendly-file-backend/services/`.

1.  **Personalization Service Implementation (e.g., `personalization_service.py`):
    *   Class/functions for the service.
    *   Methods for Mahamaya Matrix data retrieval (mock or assume existing utility).
    *   Methods for dynamic Cypher query construction.
    *   Methods for `bimba_map` interaction (calling E1.F2.S2 services or using `neo4j` driver).
    *   Implementation of the synthesis logic for the example scenarios.
    *   Definition of the internal API method(s).
2.  **Example Usage/Testing Snippet (Python):
    *   A short Python snippet demonstrating how another service might call the `personalization_service` and what the expected output might look like for one of the scenarios.
3.  **Documentation (Markdown):
    *   Brief overview of the service's role and data flow.
    *   How to use the internal API (method signature, example request/response).

**Focus on providing practical, runnable Python code for the service layer and synthesis examples. Clearly state any assumptions made about data structures in Mahamaya Matrix or `bimba_map` (beyond what's in E1.F2.S1 and E1.F2.S2).**
Assume the developer has `pymongo` and `neo4j` Python drivers installed.
```